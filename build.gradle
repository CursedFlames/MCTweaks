plugins {
	// TODO for reproducible builds and general toolchain safety, we should really pin to specific versions instead of using SNAPSHOT etc
	// see https://github.com/fractureiser-investigation/fractureiser/blob/94f35c5343732b4bf97124ce1cad5744e4ee3602/docs/2023-06-08-meeting.md#discussion-and-action-items-1
    id("fabric-loom") version "1.2-SNAPSHOT" apply(false)
    id("net.minecraftforge.gradle") version "[6.0,6.2)" apply(false)
    id("org.spongepowered.gradle.vanilla") version "0.2.1-SNAPSHOT" apply(false)
    id("org.spongepowered.mixin") version "0.7-SNAPSHOT" apply(false)
	// Publishing
	id("com.modrinth.minotaur") version "2.+" apply(false)
	id("net.darkhax.curseforgegradle") version "1.1.15" apply(false)
	// Environment variables (API keys)
	id("co.uzzu.dotenv.gradle") version "2.0.0"
	// Reproducible builds
	id("reproducible-builds") apply(false)
}

allprojects {
	apply plugin: "reproducible-builds"
}

subprojects {
    if (project.parent?.parent == rootProject) {
        apply plugin: 'java'

        java.toolchain.languageVersion = JavaLanguageVersion.of(17)
        java.withSourcesJar()

        jar {
            from(project.parent.file("LICENSE")) {
                rename { "${it}_${mod_name}" }
            }
        }

        sourcesJar {
            from(project.parent.file("LICENSE")) {
                rename { "${it}_${mod_name}" }
            }
        }

        repositories {
            mavenCentral()
            maven {
                name = 'Sponge / Mixin'
                url = 'https://repo.spongepowered.org/repository/maven-public/'
            }
            maven {
                name = 'BlameJared Maven (JEI / CraftTweaker / Bookshelf)'
                url = 'https://maven.blamejared.com'
            }
        }

        tasks.withType(JavaCompile).configureEach {

            it.options.encoding = 'UTF-8'
            it.options.getRelease().set(17)
        }

        processResources {
            filesMatching(['pack.mcmeta', 'fabric.mod.json', '*.mixins.json']) {
                expand project.properties
            }
        }

        // Disables Gradle's custom module metadata from being published to maven. The
        // metadata includes mapped dependencies which are not reasonably consumable by
        // other mod developers.
        tasks.withType(GenerateModuleMetadata).configureEach {

            enabled = false
        }
		// `switch` didn't seem to work, so we use chained `if` instead
		// TODO this is pretty messy, can we separate them into separate files in the root directory or something?
		if (project.name == "common") {
			apply plugin: 'idea'
			apply plugin: 'java'
			apply plugin: 'maven-publish'
			apply plugin: 'org.spongepowered.gradle.vanilla'

			base {
				archivesName = "${mod_name}-common-${minecraft_version}-${mod_version}"
			}
			minecraft {
				version(minecraft_version)
				if(file("src/main/resources/${mod_id}.accesswidener").exists()){
					accessWideners(file("src/main/resources/${mod_id}.accesswidener"))
				}
			}

			dependencies {
				compileOnly group:'org.spongepowered', name:'mixin', version:'0.8.5'
				implementation group: 'com.google.code.findbugs', name: 'jsr305', version: '3.0.1'
			}
		} else if (project.name == "fabric") {
			var curseProjectId = null;
			var modrinthProjectId = null;
			if (project.hasProperty("curseforge_id_fabric")) {
				curseProjectId = "${project.curseforge_id_fabric}".toString();
			} else if (project.hasProperty("curseforge_id")) {
				curseProjectId = "${project.curseforge_id}".toString();
			}
			if (project.hasProperty("modrinth_id")) {
				modrinthProjectId = "${project.modrinth_id}".toString();
			}

			apply plugin: 'java'
			apply plugin: 'idea'
			apply plugin: 'maven-publish'
			apply plugin: 'fabric-loom'
			if (modrinthProjectId != null) apply plugin: "com.modrinth.minotaur"
			if (curseProjectId != null) apply plugin: "net.darkhax.curseforgegradle"
			base {
				archivesName = "${mod_name}-fabric-${minecraft_version}-${mod_version}"
			}
			dependencies {
				minecraft "com.mojang:minecraft:${minecraft_version}"
				mappings loom.officialMojangMappings()
				modImplementation "net.fabricmc:fabric-loader:${fabric_loader_version}"
				modImplementation "net.fabricmc.fabric-api:fabric-api:${fabric_version}"
				implementation group: 'com.google.code.findbugs', name: 'jsr305', version: '3.0.1'
				implementation project.parent.childProjects.get("common")
			}

			loom {
				if (project.parent.childProjects.get("common").file("src/main/resources/${mod_id}.accesswidener").exists()) {
					accessWidenerPath.set(project.parent.childProjects.get("common").file("src/main/resources/${mod_id}.accesswidener"))
				}
				mixin {
					defaultRefmapName.set("${mod_id}.refmap.json")
				}
				runs {
					client {
						client()
						setConfigName("Fabric Client")
						ideConfigGenerated(true)
						runDir("run")
					}
					server {
						server()
						setConfigName("Fabric Server")
						ideConfigGenerated(true)
						runDir("run")
					}
				}
			}

			tasks.withType(JavaCompile).configureEach {
				source(project.parent.childProjects.get("common").sourceSets.main.allSource)
			}
			tasks.named("sourcesJar", Jar) {
				from(project.parent.childProjects.get("common").sourceSets.main.allSource)
			}

			processResources {
				from project.parent.childProjects.get("common").sourceSets.main.resources
			}

			if (curseProjectId != null) {
				task publishCurseforge(type: net.darkhax.curseforgegradle.TaskPublishCurseForge) {
					group = "publishing"
					apiToken = env.CURSEFORGE_TOKEN.value
//					debugMode = true

					// A project ID is required to tell CurseForge which project the uploaded
					// file belongs to. This is public on your project page and is not private
					// information.
					var projectId = curseProjectId

					// Tells CurseForgeGradle to publish the output of the jar task. This will
					// return a UploadArtifact object that can be used to further configure the
					// file.
					def mainFile = upload(projectId, remapJar)
					mainFile.changelogType = "markdown"
					mainFile.changelog = project.parent.file("changelog.md")
					mainFile.releaseType = "${mod_version}".startsWith("0") ? "beta" : "release"
					mainFile.displayName = "${display_mc_version}-${mod_version}-fabric"
					mainFile.addRequirement("fabric-api")
				}
			}
			if (modrinthProjectId != null) {
				modrinth {
					token = env.MODRINTH_TOKEN.value
//					debugMode = true

					projectId = modrinthProjectId
					versionNumber = project.mod_version
					versionName = "${display_mc_version}-${mod_version}-fabric"
					versionType = "${mod_version}".startsWith("0") ? "beta" : "release"
					uploadFile = remapJar
//					gameVersions = modrinthMcVersions == null ? [minecraft_version] : modrinthMcVersions.split(";").map {it.trim()}
					dependencies {
						required.project "fabric-api"
					}
					changelog = project.parent.file("changelog.md").text
					syncBodyFrom = project.parent.file("README.md").text
				}
			}
		} else if (project.name == "forge") {
			var curseProjectId = null;
			var modrinthProjectId = null;
			if (project.hasProperty("curseforge_id_forge")) {
				curseProjectId = "${project.curseforge_id_forge}".toString();
			} else if (project.hasProperty("curseforge_id")) {
				curseProjectId = "${project.curseforge_id}".toString();
			}
			if (project.hasProperty("modrinth_id")) {
				modrinthProjectId = "${project.modrinth_id}".toString()
			}

			apply plugin: 'idea'
			apply plugin: 'maven-publish'
			apply plugin: 'net.minecraftforge.gradle'
			apply plugin: 'org.spongepowered.mixin'
			if (modrinthProjectId != null) apply plugin: "com.modrinth.minotaur"
			if (curseProjectId != null) apply plugin: "net.darkhax.curseforgegradle"
			base {
				archivesName = "${mod_name}-forge-${minecraft_version}-${mod_version}"
			}
			mixin {
				add(sourceSets.main, "${mod_id}.refmap.json")

				config("${mod_id}.mixins.json")
				if (file("src/main/resources/${mod_id}.forge.mixins.json").exists()) {
					config("${mod_id}.forge.mixins.json")
				}
			}

			minecraft {
				mappings channel: 'official', version: minecraft_version

				// Automatically enable forge AccessTransformers if the file exists
				// This location is hardcoded in Forge and can not be changed.
				// https://github.com/MinecraftForge/MinecraftForge/blob/be1698bb1554f9c8fa2f58e32b9ab70bc4385e60/fmlloader/src/main/java/net/minecraftforge/fml/loading/moddiscovery/ModFile.java#L123
				if (file('src/main/resources/META-INF/accesstransformer.cfg').exists()) {
					accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg')
				}

				runs {
					client {
						workingDirectory project.file('run')
						ideaModule "${rootProject.name}.${project.parent.name}.${project.name}.main"
						taskName 'Client'
						property 'mixin.env.remapRefMap', 'true'
						property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"
						mods {
							modClientRun {
								source sourceSets.main
								source project.parent.childProjects.get("common").sourceSets.main
							}
						}
					}

					server {
						workingDirectory project.file('run')
						ideaModule "${rootProject.name}.${project.parent.name}.${project.name}.main"
						taskName 'Server'
						property 'mixin.env.remapRefMap', 'true'
						property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"
						mods {
							modServerRun {
								source sourceSets.main
								source project.parent.childProjects.get("common").sourceSets.main
							}
						}
					}

					data {
						workingDirectory project.file('run')
						ideaModule "${rootProject.name}.${project.parent.name}.${project.name}.main"
						args '--mod', mod_id, '--all', '--output', file('src/generated/resources/'), '--existing', file('src/main/resources/')
						taskName 'Data'
						property 'mixin.env.remapRefMap', 'true'
						property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"
						mods {
							modDataRun {
								source sourceSets.main
								source project.parent.childProjects.get("common").sourceSets.main
							}
						}
					}
				}
			}

			sourceSets.main.resources.srcDir 'src/generated/resources'

			dependencies {
				minecraft "net.minecraftforge:forge:${minecraft_version}-${forge_version}"
				compileOnly project.parent.childProjects.get("common")
				annotationProcessor("org.spongepowered:mixin:0.8.5-SNAPSHOT:processor")
			}

			tasks.withType(JavaCompile).configureEach {
				source(project.parent.childProjects.get("common").sourceSets.main.allSource)
			}
			tasks.named("sourcesJar", Jar) {
				from(project.parent.childProjects.get("common").sourceSets.main.allSource)
			}

			processResources {
				from project.parent.childProjects.get("common").sourceSets.main.resources
				// Doing this here instead of earlier on fixes `mods.toml` not getting processed properly, for some reason
				// TODO is this still necessary?
				filesMatching(['META-INF/mods.toml']) {
					expand project.properties
				}
			}

			jar.finalizedBy('reobfJar')

			if (curseProjectId != null) {
				task publishCurseforge(type: net.darkhax.curseforgegradle.TaskPublishCurseForge) {
					group = "publishing"
					apiToken = env.CURSEFORGE_TOKEN.value
//					debugMode = true

					// A project ID is required to tell CurseForge which project the uploaded
					// file belongs to. This is public on your project page and is not private
					// information.
					var projectId = curseProjectId

					// Tells CurseForgeGradle to publish the output of the jar task. This will
					// return a UploadArtifact object that can be used to further configure the
					// file.
					def mainFile = upload(projectId, jar)
					mainFile.changelogType = "markdown"
					mainFile.changelog = project.parent.file("changelog.md")
					mainFile.releaseType = "${mod_version}".startsWith("0") ? "beta" : "release"
					mainFile.displayName = "${display_mc_version}-${mod_version}-forge"
				}
			}
			if (modrinthProjectId != null) {
				modrinth {
					token = env.MODRINTH_TOKEN.value
//					debugMode = true

					projectId = modrinthProjectId
					versionNumber = project.mod_version
					versionName = "${display_mc_version}-${mod_version}-forge"
					versionType = "${mod_version}".startsWith("0") ? "beta" : "release"
					uploadFile = jar
//					gameVersions = modrinthMcVersions == null ? [minecraft_version] : modrinthMcVersions.split(";").map {it.trim()}
					dependencies {
					}
					changelog = project.parent.file("changelog.md").text
				}
			}
		} else {
			logger.warn("Unknown subproject ${project.name} in project ${project.parent.name}")
		}
    }
}
